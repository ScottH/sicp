
* Chapter 2 Notes and exercise solutions. 2.1 - 2.97

** Section 2.1


Here's a dotted pair. Two items that are in a list structure, but not a list
#+begin_src racket :lang sicp
  (define x (cons 1 2))
  (display "x is ")(display  x) (newline)
  (display "car x is ")(display  (car x)) (newline)
  (display "cdr x is ")(display  (cdr x)) (newline)

#+end_src

#+RESULTS:
: x is (1 . 2)
: car x is 1
: cdr x is 2
: #<void>

The rational number code from section 2.1

#+name: rational-defs
#+begin_src racket :lang sicp :results output
   (define (make-rat n d) (cons n d))
   (define (numer x) (car x))
   (define (denom x) (cdr x))

   (define (add-rat x y)
     (make-rat (+ (* (numer x) (denom y))
		  (* (numer y) (denom x)))
	       (* (denom x) (denom y))))

   (define (sub-rat x y)
     (make-rat (- (* (numer x) (denom y))
		  (* (numer y) (denom x)))
	       (* (denom x) (denom y))))

   (define (mul-rat x y)
     (make-rat (* (numer x) (numer y))
	       (* (denom x) (denom y))))

   (define (div-rat x y)
     (make-rat (* (numer x) (denom y))
	       (* (denom x) (numer y))))

   (define (equal-rat? x y)
     (= (* (numer x) (denom y))
	(* (numer y) (denom x))))


   (define (print-rat x)
     (newline)
     (display (numer x))
     (display "/")
     (display (denom x))
     (newline))
#+end_src

#+RESULTS: rational-defs

#+begin_src racket :lang sicp :noweb eval
  <<rational-defs>>
  (print-rat (add-rat (make-rat 1 4) (make-rat 3 4)))
#+end_src

#+RESULTS:
: 
: 16/16
: #<void>


** Exercise 2.1: Define a beer version of make-rat that han- dles both positive and negative arguments. make-rat should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.


** Exercise 2.2: Consider the problem of representing line segments in a plane. Each segment is represented as a pair of points: a starting point and an ending point. Define a constructor make-segment and selectors start-segment and end-segment that define the representation of segments in terms of points. Furthermore, a point can be represented as a pair of numbers: the x coordinate and the y coordi- nate. Accordingly, specify a constructor make-point and selectors x-point and y-point that define this representa- tion. Finally, using your selectors and constructors, define a procedure midpoint-segment that takes a line segment as argument and returns its midpoint (the point whose coor- dinates are the average of the coordinates of the endpoints). To try your procedures, you’ll need a way to print points:

** Exercise 2.3: Implement a representation for rectangles in a plane. (Hint: You may want to make use of Exercise 2.2.) In terms of your constructors and selectors, create procedures that compute the perimeter and the area of a given rectan- gle. Now implement a different representation for rectan- gles. Can you design your system with suitable abstraction barriers, so that the same perimeter and area procedures will work using either representation?

** Exercise 2.4: Here is an alternative procedural representa- tion of pairs. For this representation, verify that (car (cons x y)) yields x for any objects x and y.

#+begin_src racket :lang sicp
(define (cons x y) (lambda (m) (m x y)))
(define (car z)
(z (lambda (p q) p)))
What is the corresponding definition of cdr? (Hint: To ver- ify that this works, make use of the substitution model of Section 1.1.5.)
#+end_src


** Exercise 2.5: Show that we can represent pairs of nonneg- ative integers using only numbers and arithmetic opera- tions if we represent the pair a and b as the integer that is the product 2a 3b . Give the corresponding definitions of the procedures cons, car, and cdr.


** Exercise 2.6: In case representing pairs as procedures wasn’t mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as

#+begin_src racket :lang sicp
  (define zero (lambda (f) (lambda (x) x)))

  (define (add-1 n)
      (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src

this representation is known as Church numerals, afer its inventor, Alonzo Church, the logician who invented the λ-calculus.

Define one and two directly (not in terms of zero and add- 1). (Hint: Use substitution to evaluate (add-1 zero)). Give a direct definition of the addition procedure + (not in terms of repeated application of add-1).

#+begin_src racket :lang sicp
  (define foo (lambda (x) (* x x)))
(foo 3)
#+end_src

#+RESULTS:
: 9
